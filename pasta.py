############################
# Written by Logan Praneis #
############################
# These all come from Pycryptodome
from Crypto.Cipher import AES
from Crypto.Hash import SHA256
from Crypto.Random.random import randrange, getrandbits
from Crypto.Random import get_random_bytes
from Crypto.Util.number import inverse


# Standard modules
import collections
from binascii import hexlify

# Modules from filepaths 
# Should be arranged like so:
# .
# ├── pasta.py
# ├── top
# │   └── TOP.py
# └── ttg
#     ├── shoup.py
#     └── znUtil.py
import top.TOP as top  
import ttg.shoup as shoup

##########################################################################################
#
# Global Server Data
#
##########################################################################################

serverDict = {} # to hold client records
serverKeyDict = {} # to hold server 'keys' for s value

PubParam = collections.namedtuple('PubParam', 'k n t tpp opp nonce')
SecParam = collections.namedtuple('SecParam', 'pwd rho')

class CryptoError(Exception): # Simple exception class for exiting
    pass


##########################################################################################
#
# Setup Phase
#
##########################################################################################

def initialize(username, password, k, n, t):
    ''' Initializes public parameters, sets up secrets
    ``Args``
        username: (str) Plaintext username
        password: (str) Plaintext password
        k: (int) security parameter
        n: (int) Number of servers
        t: (int) threshold

    ``Returns``
        C : Hashed username
        secrets : (`SecParam`) tuple
        shares  : (list) of (i, share[i]) tuples
        vk : (tuple) (N, e) for RSA algoritm tuple
        pp : (`PubParam`) tuple
    '''
    C = int(SHA256.new(bytes(username, 'utf-8')).hexdigest(), 16)
    shares, vk, pp = globalSetup(k, n, t)
    secrets = SecParam(pwd=password, rho=randrange(1, pp.opp.n))
    return C, secrets, shares, vk, pp

def globalSetup(k, n, t):
    ''' Runs global setup, `called by initialize()`
    ``Args``
        k: (int) security parameter
        n: (int) Number of servers
        t: (int) threshold
    ``Returns``
        shares  : (list) of (i, share[i]) tuples
        vk : (tuple) (N, e) for RSA algoritm tuple
        pp : (`PubParam`) tuple
    '''
    shares, vk, tpp = shoup.setup(k, n, t)
    curve = top.setup()

    pp = PubParam( k=k, n=n, t=t, tpp=tpp, opp = curve, nonce=get_random_bytes(16))
    # Added the nonce here for the SKE

    # Set up server storage
    for i in range(1, n+1):
        serverDict[i] = {}
        serverKeyDict[i] = randrange(1, curve.n) # setting up ki

    return shares, vk, pp

##########################################################################################
#
# Registration Phase
#
##########################################################################################

def signUp(C, sec, pp):
    ''' Generate Client Record
    ``Args:``
        C: (int) Client ID
        sec: (`SecParam`) client security parameter tuple
        pp: (`PubParam`) global public parameters
    ``Returns``
        msg_dict: dict
            i : (h_i)
            dict of index to sign up tuple
    '''

    pwd_bytes = bytes(sec.pwd, 'utf-8')
    s = SHA256.new(pwd_bytes)
    pwd_hash = int(s.hexdigest(), 16)
    pwd_point = top.getPoint(pwd_hash)


    msg_dict = {}
    for i in range(1, pp.n+1):
        h = top.scalar_mult(serverKeyDict[i], pwd_point)
        x = bytes(str(h[0]), 'utf-8')
        y = bytes(str(h[1]), 'utf-8')

        s = SHA256.new()
        s.update(x)
        s.update(y)
        s.update(bytes(i))
        msg_dict[i] = s.digest()

    return msg_dict


def store(C, msg_list,  pp):
    ''' Store a single client record in ServerDict
    ``Args:``
        C: (int) Client ID
        msg: (list) list of tuples (m, h_i) generated by signUp()
        pp: (`PubParam`) global public parameters
    ``Returns``
        None
    '''
    for i in range(1, pp.n+1):
        if C in serverDict[i].keys():
            # Do nothing, client already added
            return
        serverDict[i][C] = msg_list[i]

##########################################################################################
#
# Sign-on Phase
#
##########################################################################################

def request(C, sec,  T, pp):
    ''' Initiate a request for a token
    ``Args:``
        C: (int) Client ID
        sec: (`SecParam`) client security parameter
        T: (list) list in [1..n+1], which servers are you requesting?
        pp: (`PubParam`) global public parameters
    ``Returns``
        st: () secret state
        requests: (dict) - dict of request tuples:
            i:  (C, reqi)
    '''
    if len(set(T)) < pp.t:
        raise CryptoError


    rho = sec.rho
    st = (sec, rho, T)

    # Compute Password hash on curve
    pwd_bytes = bytes(sec.pwd, 'utf-8')
    s = SHA256.new(pwd_bytes)
    pwd_hash = int(s.hexdigest(), 16)
    pwd_point = top.getPoint(pwd_hash)


    req_dict = {}
    for i in T:
        req_dict[i] =(C, top.scalar_mult(rho, pwd_point) )

    return req_dict, st

def respond(i, ski,  C,x,   reqi, vk, pp):
    '''
    ``Args:``
        i: (int) server index
        ski: (int) secret key share i
        C: (int) Client ID
        x: (int) nonce
        reqi : tuple
             (C,  reqi)
        vk: (int) verification key
        pp: (`PubParam`) global public parameters
    ``Returns``
        reslist: (list) list of responses:
            [(i, response) ... ]
            response is (zi, SKE(hi, yi)) tuple
    '''

    # here request is a (x, y) point
    C, request = reqi

    if C not in serverDict[i].keys():
        raise CryptoError
    else:
        ki = serverKeyDict[i]
        hi = serverDict[i][C]

    zi = top.scalar_mult(ki, request)

    # Set up SKE, run TTG.ParEval
    concat = bytes(str(C) + str(x), 'utf-8')
    yi = shoup.partEval(ski, vk, concat, pp.tpp)
    y2 = bytes(str(yi[1]), 'utf-8') # yi[1] is the partial token

    cipher = AES.new(hi, AES.MODE_EAX, pp.nonce) # encrypt partial token with hi
    ct, tag = cipher.encrypt_and_digest(y2)

    resi = (zi, ct)
    return resi


def finalize(st, reslist,  pp, C, x ):
    '''
    ``Args:``
        st: (int) secret state
        resdict: (dict) dict of response tuples of form i: (zi, ct)
        pp: (`PubParam`) global public parameters
        C: (int) client id
        x: (int) nonce
    ``Returns``
        tk: (int) token
    '''

    ( sec, rho, T) = st

    curve = pp.opp
    rho_inv = inverse(sec.rho, curve.n)

    hlist = []

    for i in reslist.keys():
        z = reslist[i][0]
        ct = reslist[i][1]

        # get original password point?

        h = top.scalar_mult(rho_inv, z)
        xcoord = bytes(str(h[0]), 'utf-8')
        ycoord = bytes(str(h[1]), 'utf-8')

        s = SHA256.new()
        s.update(xcoord)
        s.update(ycoord)
        s.update(bytes(i))

        h_digest = s.digest()
        cipher = AES.new(h_digest, AES.MODE_EAX, nonce=pp.nonce)
        yi = int(cipher.decrypt(ct))
        hlist.append((i, yi))

    concat = bytes(str(C) + str(x), 'utf-8')
    tk = shoup.combine(hlist, pp.tpp, pp.t, concat)

    if tk == False:
        raise CryptoError

    return tk

##########################################################################################
#
# Verification Phase
#
##########################################################################################
def verify(vk, C, x, tk, pp):
    '''
    ``Args:``
        vk: (int) verification key
        C: (int) Client ID
        x: password
        tk: (int) token generated by finalize()
        pp: (`PubParam`) global public parameters
    ``Returns``
        True - Token was valid
        False - token was invalid
    '''
    concat = bytes(str(C) + str(x), 'utf-8')
    return shoup.verify(vk, concat, tk, pp.tpp)


##########################################################################################
#
# Testing Code
#
##########################################################################################


# This is the entry point for setup
def signUpUser(username, password, k, t, n, x):
    C, secrets, shares, vk, pp = initialize(username, password, k, n, t)
    msg_list = signUp(C, secrets, pp)
    store(C, msg_list,  pp)
    return C, secrets, shares, vk, pp

# This is the entry point for requesting the token
def requestTk(C, secrets, shares, vk, pp, T, x):
    req_dict, st = request(C, secrets,  T, pp)
    res_dict = {}
    for i in T:
        res_dict[i] = respond(i, shares[i-1], C, x, req_dict[i], vk, pp)
    tk = finalize(st, res_dict, pp, C, x)
    return tk

# This is the entry point for the verification
def verifyTk(vk, C, x, tk, pp):
    ver = verify(vk, C, x, tk, pp)
    return ver


def print_test():
    username = 'test'
    password = 'password123'
    t = 4
    n = 5
    k = 2048
    x = getrandbits(128)  # random nonce
    T = [1,2,3,4]
    C, secrets, shares, vk, pp = initialize(username, password, k, n, t)

    print("Username: {}\nPassword: {}".format(username, password))
    print('Threshold:{}\nServers: {}'.format(t,n))
    print('{} bit RSA Keys'.format(k))
    print("Using nonce: ", x)
    print('User Hash', C)

    msg_list = signUp(C, secrets, pp)
    for k, v in msg_list.items():
        print('Server: {} storing user pass as: {}'.format(k,hexlify(v)))

    store(C, msg_list,  pp)

    print('User requesting Token for T = ' ,  *T )
    print('Requesting Tokens...\n')

    req_dict, st = request(C, secrets,  T, pp)
    
    for k,v in req_dict.items():
        print("From server: {} sending request: {}".format(k, str(str(v[0]) + " :" + str(v[1]))))

    res_dict = {}
    for i in T:
        res_dict[i] = respond(i, shares[i-1], C, x, req_dict[i], vk, pp)

    for k, v in res_dict.items():
        print("Server: {} Returned: {}".format(k, str(str(v[0]) + " :" + str(hexlify(v[1])))))

    print("Assembling token...\n")
    tk = finalize(st, res_dict, pp, C, x)
    print("User assembled token to: ", tk)
    print("Verifying token")
    ver = verify(vk, C, x, tk, pp)
    print("Verified? ", ver)

        
# Run test and print results
print_test()
